# Idea
## Kruskal’s algorithm

$T_0$ : no edge, $T_1$ : one edge, and so on generated by Kruskal's algorithm.  
Assume that $n$ is the first index such that there is no MST containing $T_n$.  
We call one of the MST contatining $T_{n-1}$ by $T$, and assume the $n$-th edge is $(u, v)$.  

In the path from $u$ to $v$ in $T$, there must be at least one edge in $T$ such that the edge is not in $T_i$ for every $i$, or appears after the $(u, v)$.  
Remove that edge and put $(u, v)$ instead. The new graph is also minimal.

* Tiem complexity: $E\log E$  
* caveat: Don't use `push_back` if you know the size already.  

## Prim's algorithm
$T_0$ : no edge, $T_1$ : one edge, and so on generated by Prim's algorithm.  
Assume that $n$ is the first index such that there is no MST containing $T_n$.  
We call one of the MST contatining $T_{n-1}$ by $T$, and assume the $n$-th edge is $(u, v)$.  

Remove the edge in the path from $u$ to $v$ in $T$ such that one end of the edge is in $T_{n-1}$ and the other is not in $T_{n-1}$, and put the edge $(u, v)$ instead.  
Then the new graph is connected and has correct number of edges to be a spanning tree. Also the new graph is also minimal.
* Time complexity: $E\log V$
# Code
## Kruskal’s algorithm
```cpp
#include <iostream>
#include "bits/stdc++.h"

using namespace std;

vector<int> parent;

int find_parent(int u) {
    if (u == parent[u]) return u;
    else return parent[u] = find_parent(parent[u]);
}

void merge_comp(int u, int v) { parent[find_parent(v)] = find_parent(u); }

int main() {
    cin.tie(nullptr);
    cout.tie(nullptr);
    ios::sync_with_stdio(false);

    int V, E, u, v, w;
    cin >> V >> E;
    vector<tuple<int, int, int>> edges;
    edges.resize(E);
    parent.resize(V);
    for (int i = 0; i < V; i++)parent[i] = i;
    for (int i = 0; i < E; i++) {
        cin >> u >> v >> w;
        edges[i] = {w, u - 1, v - 1};
    }
    std::sort(edges.begin(), edges.end());
    int result = 0;
    for (auto &edge: edges) {
        if (find_parent(get<1>(edge)) != find_parent(get<2>(edge))) {
            merge_comp(get<1>(edge), get<2>(edge));
            result += get<0>(edge);
        }
    }
    cout << result << '\n';

    return 0;
}
```

## Prim's algorithm
```cpp
#include <iostream>
#include "bits/stdc++.h"

using namespace std;
using Node = pair<vector<pair<int, int>>, bool>;

int main() {
    cin.tie(nullptr);
    cout.tie(nullptr);
    ios::sync_with_stdio(false);

    int V, E, u, v, w;
    cin >> V >> E;
    vector<Node> g(V);
    for (int i = 0; i < E; i++) {
        cin >> u >> v >> w;
        g[u - 1].first.emplace_back(v - 1, -w);
        g[v - 1].first.emplace_back(u - 1, -w);
    }
    int ret = 0;
    priority_queue<pair<int, int>> q;
    // weight / idx
    g[0].second = true;
    for (auto &el: g[0].first)
        q.push({el.second, el.first});

    pair<int, int> wi;

    while (!q.empty()) {
        wi = q.top();
        q.pop();
        if (g[wi.second].second)continue;
        g[wi.second].second = true;
        ret += wi.first;
        for (auto &el: g[wi.second].first) {
            if (!g[el.first].second) {
                q.push({el.second, el.first});
            }
        }
    }
    cout << -ret << '\n';

    return 0;
}
```